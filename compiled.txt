Task 1

A distributed system consists a set of computers and the communication network connecting them. Each computer works independently with their own processors and memories and collaborate with the other computers through message exchange to accomplish sophisticated tasks that is impossible for any single computer to complete. And the abscence of a fraction of the machines in the system doesn't necessarilly paralyze the system, in fact, it will continue to function in most of such scenarios. However, from the aspect outside the system, it is viewed as if it is a single computer with super computing capability.

A distributed system is a set of computers and their communication network. For a specific work, every computer could finish a part of the work and communicate the intermediate results to each other, all the computers could collaborative finish the whole work. From the aspect outside the distributed system, the system is inseparable and can't be known that which part is finished by which computer.

Basic Problems:
1. Lack of Global State
2. Lack of Common Clock
3. Indeterministic Behavior

Requirements:
1. Heterogeneity Support
2. Openness
3. Scalability
4. Security
5. Failure Tolerance
6. Concurrency
7. Transparency



Task 2

physical configuration, logical configuration, process network, distributed algorithm

Level 1: physical configuration
Level 2: logical configuration
Level 3: process network (logical distribution)  
Level 4: Distributed Algorithm


Task 3

Client-Server, Client and Server play different roles during the communication, Client is active and will request a service at any time, Server is passive and could only response the request and provide the service, Server has to be always running to ensure the service could be provided at any time.

Peer-to-Peer, Everyone play the same role during the communication, Everyone could actively request a service and(or) passively response to the request. If someone stop to provide its service, all others could still work well.


1. Client/Server£ºClients send request to server to create initial connection.Server answer the request and provide
   corresponding service to the client.
2. Peer-to-Peer£ºEvery node is equal,the resource is directly avaliable to other nodes.Peers are both client and server.


C/S:
Servers and clients are usually connected in computer network.
Servers provide services and clients request services.
Servers are always listening to requests, so that if a client initiate a connection(request) to a server, the server can receive and answer the request(provide service).
P2P:
All hosts in the network are both clients and servers. Multiple peers in networkcan share their resource together, not just 2 peers like C/S system.


Task 4

Four principles are:
a. Distributed operating system approach
The basic idea is to use a single DOS to handle all distributed computers through parallel programming, which is easier than a distributed programming. It’s a general priciple because distributed software development is originally supported through parallel programming in operating systems. This method is not popular because computer owners must give away control of their computers, which is hard to accept. Besides it requires the same system in the whole network, which is hard to accomplish because of variety of systems.

b. Distributed database approach
This idea is similar to the first one, but only involves distributed storage devices and a unique Distributed Database Manage System. This method brings a lot of advantages from DB features, allows a isolated application connects DB through DBMS, ignoring other applications. But also may cause problems, such as reduced flexibility of applying algorithms because all operations are limited to only reading and writing.

c. Protocol approach for dedicated purposes
It’s only applied for dedicated purposes, that means if a problem comes up repeatedly, then this problem can be standardised, and then a specific protocol is developed to handle this problem.
This protocol is open and easy to develop, but typically for isolated problems, one protocol can only handle limited problems. Thus it’s suitable for point to point situation, not for building a large system.

d. Distributed Programming approach
Today this approach no longer involves distributed programming languages. It’s based on sequential programming language, some extensions and middleware, and compiler will not understand requirements form those distributed applications

1. DOS Approach: In the price of compromising the atonomy of individual computing nodes, a distributed operating system, which is one layer up and in control of these computers, is able to provide functionalities through concurrent programming. 

2. DDBMS Approach: It incorporates multiple database systems and provides general database features. In addition, isolated sequential programming with simple reading and writing from the distributed database system becomes feasible without exchanging messages among distributed applications. But this is also the bottleneck that makes implementation of certain distributed algorithm difficult and more importantly, it gets increasingly hard to scale as the number of databases grows. 

3. Protocol Approach: This approach is desgined to tackle specific problems with standard protocol for communciation thus not a viable large scale solution.

4. Distributed Programming Approach: This is achieved through distributed programs that runs a different computeres throughout the network, possibly with aid from a distributed runtime system. There is no enforcement on operating systems, databases and programming languages as compared to other approaches. 


a) Distributed operating system approach: distributed software is part of the system. There is already many parallel programming paradigms, but all the nodes in the whole system should be homogeneous.
b) Distributed database approach: all distributed software access the shared database. Same system over network is no more necessary, convenient DB features are provided and sequential programs are easily isolated. But conflict could happen with shared database, and some algorithms are hard to realize.
c) Protocol approach: all softwares must be developed accordingt to protocols. Developers needn't to implement details of protocols but only functionalities. However, softwares lose some flexibility, some functions is impossible or hard to implement.
d) Distributed programming approach: softwares are written with sequential programming language and extensions, and then run on middlewares(or DRTS) over the computer network(or distributed system).


1.Distributed operating system approach£º
  Distributed programming based on operating paradigm.The disadvantage is that adoption of large system is nedded. 
2.Distributed database approach£º
  Distributed programming based on database.It is independent on application, but hard to realize.
3.Protocol approach for dedicated purposes£º
  Distributed programming based on standardized protocol.It is open and global but limited to standard functionalities.
4.Distributed Programming approach£º
  It is a combination of equential programming language,extensions and middleware.


Task 5

pros
a. It’s efficient because runtime system works more closely with programming language by getting information concerning the programs through compiler.
b. There exists competition between languages, which will result in faster advance of languages.
c. This approach offers good heterogeneity, migration and autonomy properties by using interfaces from programming languages.
d. It may build a global scale.

cons
a. Lack of dominating language, may have to install different runtime systems for each language.
b. Can’t work closely with operating system, may have side effect in efficiency.
c. It takes developers extract time to learn a new language.
d. Sometimes programmer can not get enough support from compiler because compiler doesn’t get enough information at compile time.

Pros:
1. The DRTS works closely with the compiler to retrieve information of the distribted programs thus an increase in efficiency.
2. Abcense of enforcement on language leads to competition and advancement in th field.
3. Distributed programming languages are designed and implemented to address issues such as heterogeneity, migration and autonomy which to some extend, are compromised in other distributed system approaches.
4. Global scale support for distributed programming is possible.

Cons:
1. Have to deal with multiple DRTSes at a time since they are written in different languages.
2. It is implemented with little consideration of the operating system that distributed programs will run on, thus not optimising the efficiency in this regard.3. From the programmers's perspective, learning new language constructs is not always desired.

Pros:
Language runs on corresponding DRTS with high efficiency;
Many languages are competing, concepts are evolved rapidly;
Heterogeneous systems can work together;
Languages are designed to support distributed programs on a "global" scale.
Cons:
Languages work on different DRTSes, enviroment configuration is complex and sometimes inconsistent;
Although codes run good on DRTS, but DRTS cannot work on OS with high efficiency;
Languages evolve too fast, programmer must always spend effort to learn a new tool;
Some hidden bugs cannot be found till issues occurs.


